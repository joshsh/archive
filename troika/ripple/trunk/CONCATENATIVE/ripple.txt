concatenative languages and the Semantic Web

Hi all,

I'd like to introduce a new, concatenative language aimed at Semantic Web applications.  Ripple is a Turing-complete RDF query language which borrows heavily from Joy, and has the novel property of being expressible in RDF as well as operating upon it.

I'd like to introduce an application of concatenative languages which I've been investigating: a concatenative RDF query language called Ripple.  For those unacquainted with the Semantic Web, the "Semantic Web" is a network of machine-understandable data which is to a software agent what the hypertext Web is to a person.  It replaces the unconstrained, natural language text of HTML web pages with the software-friendly subject-predicate-object triples of RDF, enabling specialized applications to make more intelligent use of the vast amounts of information on the Web (or at least, that's the vision).  Personally, I'm very interested in the procedural aspect of the Semantic Web, or the logic and algorithms which drive the crawlers, reasoners, and innovative mashups that consume and do useful things with the data.  I think the Semantic Web has a lot to gain from the "programs as data" mindset of functional programming, so I've designed a simple Semantic Web programming language which is expressed in RDF itself, called Ripple.  I decided to make Ripple a concatenative language because of the simplicity of concatenative programs and because of their resemblance to path expressions, which are very appropriate for the labeled graph model of RDF.  There's some documentation on Ripple here:
    http://ripple.projects.semwebcentral.org/
And a distribution of the Java implementation here:
    http://projects.semwebcentral.org/frs/?group_id=125

Basically, Ripple is very much like Joy and friends except that functions ("filters") may yield any number of values.  Ripple's notation has a slightly different appearance, owing to a slash symbol which represents its only operator.  For instance, whereas in Joy you would write

    2 dup.

In Ripple, you would write

    2 dup op.

or

    2/dup.

In Ripple, dup is a "passive" stack item just the literal value 2.  We need an operator, op, to consume dup and push an "active" dup filter to the stack, which then consumes the 2.  The single operator, as one of only a handful of special values, cuts down on the number of comparisons the Ripple query engine needs to make when a new program is drawn in from the data web; there are several kinds of objects Ripple recognizes as programs, but as the operations involved in checking for them and distinguishing between them are expensive, the interpreter doesn't do so until it's absolutely necessary.  Since 

    dup/rdf:type.



I tried not to lose my (Semantic Web) audience in the paper by getting 

I've been lurking this list for a few weeks now, and thought it was about time to speak up and i


Below are some details of the language in a format 

Best,

Josh




I'm particularly interested in bringing the "programs as data" idea to expressing those programs in RDF itself

I think it would be particularly interesting to express the programs which 


My recent project is a concatenative RDF query language called Ripple which has the novel property of being expressed in RDF as well as querying it.


It has to do with the Semantic Web and the "programs as data" idea of functional programming. 
I've been lurking this list for a few weeks now, and think it's about time to speak up and

2 dup  --  2 dup op -- 2/dup


1 2 [dup] dip  --  1 2 dup dip op  --  1 2 dup /dip



 the programs which drive those applications, and in 


logic and algorithms of which drive those applications, and in bringing 


: concatenative query languages for the Semantic Web.  



: concatenative query languages for the Semantic Web.


I've been watching this list attentively for the last few weeks, 


500-word description

the paper assumes some familiarity with RDF, but...
criticism?


stack primitives follow Joy except where there was a compelling reason not to:
cat -- shorter than concat

variants:
i and dip -- do "more"
true and false -- are primitive functions, not just constants



1. Is it a concatenative language?
From what I understand, Ripple is concatenative but not flat.  The textual syntax (as opposed to the RDF-level or tree syntax) includes quotations, like Joy.  Additionally, the slash operator can't be separated from the item it modifies: (2 /dup) is a valid program and (dup) is a valid program, but (2 /) is not.

2. Composition

	compositional pipeline
	compositional syntax

3. use of the stack
Lazy evaluation at the head of the stack (more details in the paper).

	evaluation
	stream of stacks

Q: Are stacks reflective?
A: For now, stacks are reflective in that I've implemented Joy's "stack" function which pushes the stack as a list.  However, I haven't used it, and it may be a temporary feature.

Q: Bound variables?
A: None.  Ripple works with anonymous lists and other "blank nodes", URIs as global constants, and literal values.

Q: Does it have a simple, straightforward structure?
A: Yes.  I think that follows from concatenativity.  Semantic Web data structures tend to be very simple, and a concatenative language makes it possible to express programs with complex behavior very simply, so this was a motivating factor in choosing a concatenative model for my query language.

Q: How useful is it for general programming?
A: It does alright, but it was built for and is best suited to applications involving multivalued relations.  Otherwise, you might as well use Joy or another single-input, single-output stack language.  That is, unless you're interested in *distributed* general purpose programs, 

Q: What control constructs does it include?
A: Currently, it borrows the "ifte", "branch", "choice" and "times" functions from Joy.

Q: Is the style predominantly iterative or recursive?
A: Recursive.  Even the "times" function is a recursive function, internally.

Q: How verbose is the language?
A: Comparable to Joy in that respect.  Ripple adds the slash prefix, which makes some programs a little longer, others a little shorter.  At the RDF level, Ripple is more verbose than Joy on account of repetitive use of the "op" symbol.

Q: How programmer-efficient is it?
A: Comparable to Joy, and 

Q: Does it support an interactive style?
A: The Java implementation includes an interactive command-line interpreter, complete with tab completion and command history.

9. programmer-efficient programming
	compact code
	definition is easy

Q: Does code = data?
A: Yes.  The stated purpose of the language is to express RDF queries in RDF itself.

Q: How far is it from the hardware?
A: Pretty far.  Ripple is meant to operate on metadata, which is pretty abstract stuff.  There are no functions which deal with input/output, environment variables, memory management, etc.

Q: How does it manage its memory?
A: It doesn't.  Java does :-)  Management of an RDF triple store is an interesting research topic, but is outside of the scope of this project.

Q: How is its performance?
A: I have not yet compared Ripple's performance to that of SPARQL implementations or of other RDF query processors.  It's certainly not a number cruncher, but it's not meant to be.

Q: What is the execution model?
A: Execution takes the form of lazy evaluation at the head of the stack.  


12.1. execution model
	push-model evaluator

13, closeness of fit between code and problem
	as an RDF query language, very close


