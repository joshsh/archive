{\rtf1\adeflang1037\ansi\ansicpg1252\uc1\adeff0\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe2052{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}{\f47\froman\fcharset238\fprq2 Times New Roman CE;}
{\f48\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f50\froman\fcharset161\fprq2 Times New Roman Greek;}{\f51\froman\fcharset162\fprq2 Times New Roman Tur;}{\f52\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\f53\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f54\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f55\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f57\fswiss\fcharset238\fprq2 Arial CE;}
{\f58\fswiss\fcharset204\fprq2 Arial Cyr;}{\f60\fswiss\fcharset161\fprq2 Arial Greek;}{\f61\fswiss\fcharset162\fprq2 Arial Tur;}{\f62\fbidi \fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f63\fbidi \fswiss\fcharset178\fprq2 Arial (Arabic);}
{\f64\fswiss\fcharset186\fprq2 Arial Baltic;}{\f65\fswiss\fcharset163\fprq2 Arial (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;
\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch \af0\afs24\alang1037 \ltrch \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive \ssemihidden Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch \af0\afs20 \ltrch \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}}{\*\latentstyles\lsdstimax156\lsdlockeddef0}
{\*\rsidtbl \rsid5711368\rsid12203855\rsid15676729}{\*\generator Microsoft Word 11.0.6359;}{\info{\author Joshua Shinavier}{\operator ewu}{\creatim\yr2005\mo4\dy14\hr12\min35}{\revtim\yr2005\mo4\dy16\hr18\min10}{\version4}{\edmins6}{\nofpages4}
{\nofwords1277}{\nofchars7284}{\*\company EWU}{\nofcharsws8544}{\vern24703}}\ltrsect \widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3
\jcompress\viewkind4\viewscale100\nolnhtadjtbl\rsidroot5711368 \fet0\ltrpar \sectd \ltrsect\linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}
{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}
{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \ltrpar
\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \rtlch \af0\afs24\alang1037 \ltrch \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch \af1\afs20 \ltrch \f1\fs20\insrsid5711368 
\par Josh Shinavier
\par Directed Study Spr. 05
\par Project report #1
\par 
\par 
\par Overview -------------------------------------------------------------------------------
\par 
\par   Last Fall quarter I built a language called SNPL with which I explored some ideas
\par   relating to applicative languages and "associational" data structures.  As an
\par   exercise in language design I got what I wanted out of it, but the quirky expression
\par   syntax I'd invented made it too unreadable to be of much use as a  programming tool.
\par   This quarter I plan to develop a new language, called Phase2, in which the inner
\par   workings of the language are more clearly separated from the details of syntax and
\par   encoding.  I've chosen XML Schema as the document model for an intermediate
\par   layer between command line code and run-time data structures (specifically, the
\par   SOAP schema, because it allows for multireferencing data sets and because I'd like
\par   to experiment with distributed programming at some point).
\par 
\par 
\par The intermediate "language" ------------------------------------------------------------
\par 
\par   The XML schema at the bottom of this report defines a DataSet type which will be
\par   the basis for programs and data storage in Phase2.  Data elements may belong to
\par   any of a number of basic types corresponding to the primitive types of the language.
\par   Expressions in the language are simply nested sequences of elements.  Additionally,
\par   data elements may be arbitrarily "associated" with one another, an important feature
\par   which I'll explain in another report.
\par 
\par 
\par Expression Syntax ----------------------------------------------------------------------
\par 
\par   At the parser level, an expression is }{\rtlch \af1\afs20 \ltrch \f1\fs20\insrsid15676729 a }{\rtlch \af1\afs20 \ltrch \f1\fs20\insrsid5711368 parenthetically nested list of dictionary
\par   items or special symbols, terminated by a semicolon.  To give an expression (or the
\par   result of an evaluated expression) a name, the semicolon may be preceded by an
\par   equality symbol and then the name, e.g.
\par 
\par       (token1 token2) token3 = token4;
\par   
\par   The actual syntax will be just a little more complex than this, including quoted
\par   strings with escape characters and possibly one or two other pairs of delimiting
\par   characters such as square braces.  The unorthodox placement of the dictionary
\par   assignment command at the end of the expression caters to command-line applications
\par   for which the programs you write will not necessarily be read as you type them.
\par   After all, you might not need to give an expression a name (particularly if you're
\par   only interested in the side-effects); the trailing assignment command lets you put
\par   that decision off till the last moment.  SNPL's command-line syntax even included a
\par   special symbol to grab the result of the last expression after it has been
\par   evaluated and either give it a name or plug it into the next expression.
\par 
\par 
\par Command Syntax -------------------------------------------------------------------------
\par 
\par   Special commands (e.g. for importing and exporting data sets, exiting or
\par   manipulating the interpreter environment) will be indicated with a slash plus the
\par   name of the command, followed by a whitespace-delimited list of arguments (no
\par   parentheses) and terminated by a semicolon, e.g.
\par 
\par       /command arg1 arg2;
\par 
\par   Commands thus indicated do not belong to the program under construction, and are to
\par   take immediate effect at parse time.
\par 
\par 
\par An example data set ------------------------------------------------------------
\par 
\par   Here is a data set embedded in a SOAP envelope (sans header, as we're not
\par   actually sending it anywhere).  Elements whose id's begin with an underscore
\par   are anonymous, while those that don't are dictionary entries.  Data sets may
\par   reference elements from other data sets, although the way in which they can do
\par   so will be restricted.  Every data set contains a reference to the XML schema
\par   of a specific version of Phase2, and should not validate if there is a version discrepancy.
\par 
\par 
\par <soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
\par soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">
\par   <soap:Body>
\par     <P2:DataSet xmlns:P2="http://foo.org/Phase2_v0.xsd"
\par     xmlns:xs="http://www.w3.org/2001/XMLSchema"
\par     name="dummy data set" creationDate="2005-04-13" creationTime="11:02:45.123">
\par 
\par       <!-- An integer associated with a string via a "description" -->
\par       <P2:Element id="forty-two">
\par         <xs:integer>42</xs:integer>
\par         <P2:Association>
\par           <key soap:href="#_0"/>
\par           <target soap:href="#_1"/>
\par         </P2:Association>
\par       </P2:Element>
\par 
\par       <!-- A string without (outbound) associations -->
\par       <P2:Element id="_0">
\par         <xs:string>description</xs:string>
\par       </P2:Element>
\par 
\par       <!-- Target of the above association -->
\par       <P2:Element id="_1">
\par         <xs:string>The Answer to the ultimate Question</xs:string>
\par       </P2:Element>     
\par 
\par       <!-- This Sequence contains an Element from another DataSet -->
\par       <P2:Element id="_2">
\par         <P2:Sequence sequenceType="delayed">
\par           <P2:Element href="#forty-two"/>
\par           <P2:Element href="htt}{\rtlch \af1\afs20 \ltrch \f1\fs20\insrsid12203855 p://foo.org/someOtherDataSet.xml}{\rtlch \af1\afs20 \ltrch \f1\fs20\insrsid5711368 #_5"/>
\par         </P2:Sequence>
\par       </P2:Element>
\par 
\par     </P2:DataSet>
\par   </soap:Body>
\par </soap:Envelope>
\par 
\par 
\par First draft of the schema --------------------------------------------------------------
\par 
\par   Here's a preliminary XML schema for the save format.  The definition of PrimitiveType
\par   will eventually be inherited from a separate document.  A collection of primitive
\par   functions with their parameter types will be placed in a third XML document (but not
\par   a schema).
\par 
\par 
\par <?xml version="1.0" encoding="UTF-8"?>
\par <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
\par elementFormDefault="qualified"
\par attributeFormDefault="unqualified">
\par 
\par   <!-- This union should correspond 1:1 with the set of primitive types
\par   supported by the appropriate version of the language, and must include the
\par   PrimitiveFunction, PlaceHolder and Sequence types defined below. -->
\par   <xsd:element name="PrimitiveType">
\par     <xsd:complexType>
\par       <xsd:union>
\par         <xsd:element ref="PrimitiveFunction"/>
\par         <xsd:element ref="PlaceHolder/>
\par         <xsd:element ref="Sequence"/>
\par         <xsd:element ref="xsd:string"/>
\par         <xsd:element ref="xsd:integer"/>
\par         [...]
\par       </xsd:union>
\par     </xsd:complexType>
\par   </xsd:element>
\par 
\par   <!-- Define the PrimitiveFunction type. -->
\par   <xsd:element name="PrimitiveFunction">
\par     <xsd:complexType>
\par       <xsd:simpleContent>
\par         <!-- Note: restrictions on functionName are probably best left to
\par         specific parser applications. -->
\par         <xsd:attribute name="functionName" type="string"/>
\par       </xsd:simpleContent>
\par       <xsd:element ref="PrimitiveType" maxOccurs="unbounded"/>
\par     </xsd:complexType>
\par   </xsd:element>
\par 
\par   <!-- Define the PlaceHolder (empty) type -->
\par   <xsd:element name="PlaceHolder">
\par     <xsd:complexType/>
\par   </xsd:element>
\par 
\par   <!-- Define the Sequence type -->
\par   <xsd:element name="Sequence">
\par     <xsd:complexType>
\par       <xsd:simpleContent>
\par         <xsd:attribute name="sequenceType">
\par           <xsd:simpleType>
\par             <xsd:restriction base="xsd:string">
\par               <xsd:enumeration value="immediate"/>
\par               <xsd:enumeration value="delayed"/>
\par             </xsd:restriction>
\par           </xsd:simpleType>
\par         </xsd:attribute>
\par       </xsd:simpleContent>
\par       <xsd:element ref="Element" minOccurs="0" maxOccurs="unbounded"/>
\par     <xsd:complexType>
\par   </xsd:element>
\par 
\par   <!-- Define the Association type (it's just an ordered pair of Elements) -->
\par   <xsd:element name="Association">
\par     <xsd:complexType>
\par       <xsd:sequence>
\par         <xsd:element name="key" type="Element"/>
\par         <xsd:element name="target" type="Element"/>
\par       </xsd:sequence>
\par     </xsd:complexType>
\par   </xsd:element>
\par 
\par   <!-- Define the Element type.  An Element is an instance of a PrimitiveType together
\par   with an unordered (and possibly empty) collection of Associations -->
\par   <xsd:element name="Element">
\par     <xsd:complexType>
\par       <xsd:sequence>
\par         <xsd:element name="value" type="PrimitiveType"/>
\par         <xsd:element ref="Association" minOccurs="0" maxOccurs="unbounded"/>
\par       </xsd:sequence>
\par     </xsd:complexType>
\par   </xsd:element>
\par 
\par   <!-- Define the DataSet type -->
\par   <xsd:element name="DataSet">
\par     <xsd:complexType>
\par       <xsd:simpleContent>
\par         <xsd:attribute name="name" type="xsd:string"/>
\par         <xsd:attribute name="creationDate" type="xsd:date"/>
\par         <xsd:attribute time="creationTime" type="xsd:time"/>
\par       </xsd:simpleContent>
\par       <xsd:element ref="Element" maxOccurs="unbounded"/>
\par     </xsd:complexType>
\par   </xsd:element>
\par 
\par </xsd:schema>
\par }}