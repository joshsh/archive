


>>  CONS 1 (CONS 2 ()) =: ntl;

...where CONS is an alias for the V combinator.

>>  TAIL (TAIL ntl);



                                 P H A S E 2

Namespaces

Zero Element
The zero element, represented by the empty expression "()", is a unique value
such that for any primitive value v,
    () v = v () = ()
The zero element has no type, and behaves like the equivalent entity in Lisp.
It is particularly useful for halting recursion.

Combinators

Association
Phase2 

Primitives
importing
r. transparency


An experimental language API and interpreter which combine ideas from functional programming and the Semantic Web.  Also includes a graphical namespace browser (requires Qt4 to compile) in its early stages.


Phase2 is the continuation of a undergraduate compiler project and is not aimed at any particular user niche.  I do not expect it compete with the likes of Scheme or Haskell as a mainstream software development or research tool.  It does, however, have some novel features which may be of interest to language developers, and the interpreter serves as a proof-of-concept for these ideas.  Although I personally use Phase2 for practical work, this is alpha software under active development.  I'm submitting the project to SourceForge solely on the basis that it is an interesting concept language.  Some details on the language follow.

The motivation for Phase2 is that the same "triples" ontologies used for knowledge representation can just as well express functional programs.  Computation then takes the form of a sort of tensor reduction operating on a set of triples.  Unlike RDF, Phase2 makes no distinction between subject and predicate as classes of objects, and each vertex of a graph potentially acts as a function over the domain of all vertices (i.e. is a property).  Objects are strictly typed, and may be combined according to their type to yield new objects.  For now, combinator expressions and algorithms do most of the heavy lifting of function closures and graph reduction.  Type agreement is checked dynamically, with simple inference binding new objects to types.  A tracing memory manager keeps the size of the heap in check.

Phase2 uses a network model to organize and navigate through programs and data.  A namespace is a first-class object which binds identifiers to arbitrary objects, including other namespaces.  In the interpreter, namespaces inherit the identifiers of any child namespaces as well as the root namespace which determines the set of reachable objects.  For example, the simple name "Arkansas" is equivalent to the fully-qualified name "geography:US:states:Arkansas" so long as there is not a shorter path to a different object with the same name.  In actual use, I've found name collisions to be relatively infrequent, so this "nearest match" name resolution saves on a lot of typing when working with a large, complex network of named items.  When in doubt, simply type in a name as a complete expression, e.g. "Arkansas;" and see what it binds to in the current working namespace.

The Phase2 package is built with autotools and qmake.  The API and interpreter are written in C with GNU extensions, while the GUI is written in Qt/C++.  Adding new primitives to the API is as simple as dropping a C header file into a special directory and re-compiling with the appropriate options: the build process uses doxygen to pick up the function's name and type signature, and xsltproc to generate stubs and constructor calls to build the primitive at invocation time.  Most of the functions in the C standard library can be made available in this way.  You can also import new primitive data types by tagging special functions as essential methods for the type.










./cleanup
./bootstrap
./configure

(./configure --enable-debug)

make 2>stderr.txt; cat stderr.txt

make dist
make install
make doxygen-doc


valgrind -v --tool=memcheck --leak-check=full --show-reachable=yes src/.libs/lt-phase2


################################################################################
# Cross-compiling libxml2

export CC=your compiler
./configure with proper options
make
make install


################################################################################
# Cross-compile Phase2 for ARM.

THE SECRET KLUDGE for creating an error-free, debuggable ARM phase2 executable:
1) generate phase2.so using the (crosstool) gcc4 cross-compiler
2) generate phase2 (with 'main') using (Embedix) gcc2 cross-compiler
3) put phase2.so in /usr/lib and invoke phase2


ARM_PREFIX=/opt/Embedix/tools/

CROSSTOOL=/home/joshs/bin/crosstool-0.42
CROSSTOOL=/opt/crosstool/crosstool-0.42

ARM_PREFIX=$CROSSTOOL/result/gcc-4.1.0-glibc-2.3.2/arm-unknown-linux-gnu/arm-unknown-linux-gnu/

# First, cross-compile libxml2 and place the ARM libraries into $ARM_PREFIX/lib

# Necessary when using crosstools binaries.
PATH=$ARM_PREFIX/bin:$PATH

# Note: rationale behind also specifying --build:
#     http://www.gnu.org/software/autoconf/manual/autoconf-2.57/html_node/autoconf_164.html
./configure --host=arm-linux --build=i686-pc-linux-gnu --prefix=$ARM_PREFIX

make

# Look in here for the ARM executables and libraries:
#     src/.libs/


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


%destructor

libtool --mode=execute gdb src/phase2

Qt4/C++

$(LIBOBJS) and $(ALLOCA)

     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix

./configure --host=arm-linux --with-linux=$ARM_PREFIX/include

The linker also needs to be arm-linux-ld not ld.


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


