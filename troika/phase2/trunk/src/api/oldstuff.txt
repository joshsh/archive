

/* "Mark and sweep" memory management *****************************************/

#ifdef MEM__MARK_AND_SWEEP

    /*#include "util/p2_term.h"*/

    /** Marks an atom, and subsequently checks the edge marking queue for other
        atoms which need to be handled. */
    void p2_object__mark(p2_object *o);

    /** Marks all atoms referenced by the given p2_term.
        \note  This function assumes that type identifiers are positive (it
       "marks" an atom by reversing the sign of its type id). */
    /*void p2_mark(p2_term *term);*/

    /** Deallocates all unmarked atoms and unmarks the rest. */
    void p2_sweep();

    /** Returns the number of atoms in the "mark and sweep" collection. */
    unsigned int p2_total_markandsweep_atoms();

#endif  /* MEM__MARK_AND_SWEEP */




#ifdef MEM__MARK_AND_SWEEP

#include "util/p2_bunch.h"
#include "util/p2_term.h"
#include "util/p2_set.h"

/** A global collection of pointers which references all objects in the
    environment at a given time.  Memory can be reclaimed by eliminating
    orphan objects with the mark and sweep functions. */
p2_bunch *markandsweep_objects = 0;

/** Atoms in this queue have already been marked, however they may have outbound
    edges which need to be investigated.
    \note  This collection is always null outside of a mark and sweep interval,
    and is initialized in add_to_queue. */
p2_bunch *edge_marking_queue = 0;

#ifdef P2FLAGS__ASSOCIATION

/** A global lookup table for "trigger" tables.
    \note  This table is is always null outside of a mark and sweep interval,
    and is initialized in mark_edge. */
p2_hash_table *all_triggers = 0;

#endif  // P2FLAGS__ASSOCIATION

#endif  // MEM__MARK_AND_SWEEP



//!
p2_object *p2_error_object(p2_error err) { return 0 ; }
p2_type p2_term__type = (p2_type) 655321;
p2_type p2_set__type = (p2_type) 655322;


p2_error p2_object_init()
{
    #ifdef MEM__MARK_AND_SWEEP
        // Initialize "mark and sweep" collection.
        markandsweep_objects = p2_bunch__new(P2FLAGS__MARKANDSWEEP_ATOMS__BLOCK_SIZE);
    #endif

    return P2_SUCCESS;
}



p2_error p2_object_end()
{
    #ifdef MEM__MARK_AND_SWEEP
    p2_sweep();

    if (markandsweep_objects)
    {
        p2_bunch__delete(markandsweep_objects);
        markandsweep_objects = 0;
    }
    #endif

    return P2_SUCCESS;
}



// "Mark and sweep" memory reclamation /////////////////////////////////////////


#ifdef MEM__MARK_AND_SWEEP


unsigned int p2_total_markandsweep_objects()
{
   if (markandsweep_objects)
        return p2_bunch__size(markandsweep_objects);
   else
        return 0;
}


//void *(*)(void *, void *)

/** \return  a type-specific "apply to all" function, or 0 if the argument is
    not of a collection type. */
void *(*distributing_function (p2_type type))(void *, void *(*)(void *))
{
    if (type == p2_term__type)
        return (void *(*)(void *, void *(*)(void *))) p2_term__for_all;
    else if (type == p2_set__type)
        return (void *(*)(void *, void *(*)(void *))) p2_set__for_all;
    else
        return 0;
}


/** Adds an object to the edge-marking queue. */
void add_to_queue(p2_object *object)
{
    if (!edge_marking_queue)
        edge_marking_queue = p2_bunch__new(P2FLAGS__MARKANDSWEEP_QUEUE__BLOCK_SIZE);

    p2_bunch__add(edge_marking_queue, object);
}


void *mark_object(p2_object *object)
{
    // If the object has not already been marked...
    if (object->type > 0)
    {
        // Mark the object by reversing the sign of its type.
        object->type = (p2_type) -((unsigned int) object->type) ;

        // Before interfering with the object's type...
        #ifdef P2FLAGS__ASSOCIATION
            // This object may have edges which need to be investigated.
            add_to_queue(object) ;

            // Flip any "triggers" bound to this object.
            p2_hash_table *triggers = p2_hash_table__lookup(all_triggers, object);
            if (triggers)
            {
                // Mark each object in the argument object's trigger table.
                p2_hash_table__for_all(triggers, (void (*)(void *, void *)) mark_object);

                // The marked object has no more need for a trigger table.
                p2_hash_table__remove(all_triggers, triggers);
                p2_hash_table__delete(triggers);
            }
        #else
            // If there are no associative edges, then only parent-child edges
            // are possible.
            if (distributing_function(-object->type))
                add_to_queue(object) ;
        #endif
    }

    // Perfunctory nonzero return value.
    return (void *) 1;
}


#ifdef P2FLAGS__ASSOCIATION

void mark_edge(p2_object *key, p2_object *target)
{
    // If the target has not already been marked...
    if (target->type > 0)
    {
        // If the key is already marked, then we can immediately mark the target.
        if (key->type < 0)
            mark_object(target) ;

        // Otherwise, set up a "trigger" which will cause the target object to be
        // marked in the event that the key is marked.
        else
        {
            // Initialize the trigger table lookup table if necessary.
            if (!all_triggers)
                all_triggers = p2_hash_table__new(
                    P2FLAGS__INIT_MARKANDSWEEP_BUFFER_SIZE, 0, 0, ADDRESS_DEFAULTS);

            // Find or create the appropriate trigger table.
            p2_hash_table *triggers = p2_hash_table__lookup(all_triggers, key);
            if (!triggers)
            {
                triggers = p2_hash_table__new(
                    P2FLAGS__INIT_TRIGGER_BUFFER_SIZE, 0, 0, ADDRESS_DEFAULTS);

                p2_hash_table__add(all_triggers, key, triggers);
            }

            // Add a trigger to the table.
            p2_hash_table__add(all_triggers, triggers, target);
        }
    }
}

#endif  // P2FLAGS__ASSOCIATION


/** Marks all of an object's outbound edges. */
void mark_outbound_edges(p2_object *object)
{
    #ifdef P2FLAGS__ASSOCIATION

        // If the object has any outbound associations...
        if (object->outbound_edges)
        {
            // Investigate each outbound associative edge.
            p2_hash_table__for_all(object->outbound_edges,
                (void (*)(void *, void *)) mark_edge) ;
        }

    #endif

    // Note: this logic assumes that the argument object has already been marked.
    void *(*for_all)(void *, void *(*)(void *))
        = distributing_function((p2_type) -((unsigned int) object->type)) ;

    // If the argument object is of a collection type, mark each child object.
    if (for_all)
        for_all(object->value, (void *(*)(void *)) mark_object) ;
}


void p2_object__mark(p2_object *object)
{
    mark_object(object) ;

    if (edge_marking_queue)
    {
        while (edge_marking_queue->last_block->filled)  //~?
        {
            object = (p2_object *) p2_bunch__remove(edge_marking_queue) ;
            mark_outbound_edges(object) ;
        }
    }
}


p2_object *unmark(p2_object *object)
{
    if (object->type < 0)
    {
        object->type = (p2_type) -((unsigned int) object->type);

        // Don't exclude this object.
        object = 0;
    }
    else
        p2_object__delete(object);

    return object;
}


void p2_sweep()
{
    // Unmark all marked objects in the environment, and delete the rest.
    markandsweep_objects = p2_bunch__exclude_if(markandsweep_objects, (void *(*)(void *)) unmark);

    // Eliminate the edge marking queue.
    if (edge_marking_queue)
    {
        p2_bunch__delete(edge_marking_queue);
        edge_marking_queue = 0;
    }

    #ifdef P2FLAGS__ASSOCIATION

        if (all_triggers)
        {
            // Delete all remaining trigger tables.
            p2_hash_table__for_all_targets(
                all_triggers,
                (void (*)(void *)) p2_hash_table__delete);

            // Eliminate the global lookup table.
            p2_hash_table__delete(all_triggers);
            all_triggers = 0;
        }

    #endif
}


#endif  // MEM__MARK_AND_SWEEP













/** Retrieves a type identifier by name. */
p2_type *p2_type__lookup( char *name );

/**  */
/*char *p2_type_name( p2_type *type );*/




#include "util/p2_array.h"
#include "util/p2_hash_table.h"



// Global variables for this module only.
p2_array *registered_types;
p2_hash_table *type_dictionary;
int total_types_ = 0;


int p2_total_types()
{
    return total_types_;
}



p2_type p2_type_lookup(char *name)
{
    return (p2_type) p2_hash_table__lookup(type_dictionary, (void *) name);
}







p2_error p2_type_init()
{
    registered_types = p2_array__new(30, 2.0);
    type_dictionary = p2_hash_table__new(60, 2.0, 2.0, STRING_DEFAULTS);

    return P2_SUCCESS;
}



p2_error p2_type_end()
{
    p2_array__forall(registered_types, (void (*)(void *)) p2_type__delete);
    p2_array__delete(registered_types);
    p2_hash_table__delete(type_dictionary);

    return P2_SUCCESS;
}



p2_type p2_register_type(
    char *name,
    void (*encode)(void *, char *),
    void *(*decode)(char *),
    void (*destroy)(void *),
    void *(*clone)(void *))
{
    struct p2_type_itf *type = (struct p2_type_itf *) malloc(sizeof(struct p2_type_itf));
    type->name = strdup(name);

    type->encode = encode ? encode : default__encode;
    type->decode = decode ? decode : default__decode;
    type->destroy = destroy ? destroy : default__destroy;
    type->clone = clone ? clone : default__clone;

    // Important: the type with index 1 actually is at position 0 in the array.
    // The 0 index is avoided so that it can't be mistaken for a NULL.
    p2_array__enqueue(registered_types, (void *) type);
    p2_hash_table__add(type_dictionary, (void *) name, (void *) ++total_types_);

    return (p2_type) total_types_;
}





















/******************************************************************************/

#ifdef P2FLAGS__MANAGE_PRIMITIVES

    p2_error p2_primitive_init();

    p2_error p2_primitive_end();

    p2_primitive *p2_primitive__lookup( char *name );

    /** Serialize a p2_primitive to a string. */
    void p2_primitive__encode( p2_primitive *p, char *buffer );

    /** Deserialize a p2_primitive from a string. */
    p2_primitive *p2_primitive__decode( char *buffer );

#endif  /* P2FLAGS__MANAGE_PRIMITIVES */


#ifdef P2FLAGS__MANAGE_PRIMITIVES


p2_array *registered_primitives_;
p2_hash_table *primitives_dictionary_;


p2_error p2_primitive_init()
{
    registered_primitives_ = p2_array__new(30, 2.0);
    primitives_dictionary_ = p2_hash_table__new(60, 2.0, 2.0, STRING_DEFAULTS);

    return P2_SUCCESS;
}


p2_error p2_primitive_end()
{
    p2_array__forall(registered_primitives_, (void (*)(void *)) p2_primitive__delete);
    p2_array__delete(registered_primitives_);
    p2_hash_table__delete(primitives_dictionary_);

    return P2_SUCCESS;
}


void p2_primitive__register(p2_primitive *prim)
{
    p2_array__enqueue(registered_primitives_, (void *) prim);
    p2_hash_table__add(primitives_dictionary_, (void *) prim->name, (void *) prim);
}


void p2_primitive__encode(p2_primitive *p, char *buffer)
{
    sprintf(buffer, p->name);
}


p2_primitive *p2_primitive__decode(char *buffer)
{
    return (p2_primitive *) p2_hash_table__lookup(primitives_dictionary_, (void *) name);
}


#endif  /* P2FLAGS__MANAGE_PRIMITIVES */

























GSOAP   = $(GSOAP_PATH)/soapcpp2
SOAPH   = $(GSOAP_PATH)/stdsoap2.h
SOAPC   = $(GSOAP_PATH)/stdsoap2.c
SOAPCPP = $(GSOAP_PATH)/stdsoap2.cpp
DOMCPP  = $(GSOAP_PATH)/dom++.cpp

CPP     = g++

GSOAP_OUTPUT = \
	p2.nsmap
	# ....


#P2_OBJECTS = \
#	p2_error.o \
#	p2_command.o \
#	p2_type.o \
#	#p2_primitive.o



CORE_LIBS = \
	p2.c \
	p2_error.c \
	p2_type.c \
	p2_primitive.c

APP_LIBS = \
	sk/sk.c \
	p2_syntax.c \
	p2_command.c \
	p2_dataset.cpp \
	p2_client.cpp \
	$(SOAP_PATH)/xmldom.h $(SOAP_PATH)/xmldom.cpp \
	$(IMPORT_PATH)/primitives.cpp \
	$(IMPORT_PATH)/commands.cpp


	-rm -f *.o *.wsdl *.xsd *.xml *.nsmap *.log soap*.* phase2

phase2 :  $(CORE_LIBS) $(APP_LIBS) $(UTIL_OBJECTS) $(PARSER_OBJECTS) p2.nsmap # $(UTIL_OBJECTS) $(SOAP_PATH)/xmldom.h $(SOAP_PATH)/xmldom.cpp commands.cpp $(GSOAP_OUTPUT) p2_flags.h 
	$(CPP) -o phase2 -I$(GSOAP_PATH) $(CFLAGS) \
		$(UTIL_OBJECTS) \
		$(PARSER_OBJECTS) \
		p2_client.cpp \
		$(SOAP_PATH)/xmldom.cpp \
		$(SOAPCPP) $(LIBS) $(DOMCPP) soapC.cpp soapClient.cpp \
		#p2_dataset.o \
		#$(APP_LIBS) \
		#$(CORE_LIBS) \
		#$(SK_PATH)/sk.c \



################################################################################
# Invoke gSOAP's "stdsoap2" to generate proxy code.

p2.nsmap : $(SOAP_PATH)/gsoap_header.h
	$(GSOAP) $(SOAP_PATH)/gsoap_header.h


################################################################################
# Compile p2_error and p2_command libraries.

#p2_error.o : p2_error.c p2_flags.h
#	$(CC) -c p2_error.c

#p2_syntax.o : p2_syntax.c p2_flags.h
#	$(CC) -c p2_syntax.c

#p2_command.o : p2_command.c p2_error.h $(UTIL_PATH)/p2_array.h $(UTIL_PATH)/p2_hash_table.h
#	$(CC) -c p2_command.c
#	
#p2_type.o : p2_type.c p2_error.h $(UTIL_PATH)/p2_array.h $(UTIL_PATH)/p2_hash_table.h
#	$(CC) -c p2_type.c
#	
#p2_primitive.o : p2_primitive.c p2_error.h $(UTIL_PATH)/p2_array.h $(UTIL_PATH)/p2_hash_table.h
#	$(CC) -c p2_primitive.c


################################################################################
# Compile the p2_data_set class.

p2_dataset.o : p2_dataset.cpp p2_dataset.h
	$(CPP) -c p2_dataset.cpp



