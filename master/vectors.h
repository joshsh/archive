//I intend to write functions for determining whether a family of
//vecors is linearly dependent or not, for finding an orthonormal
//basis of the vector space generated by a family, and so forth, as
//soon as I have the time and can figure out how to define the
//vectors and vector familes.  Eventually complex vectors must also
//be handled.

struct vect2{
  double x, y;
};
 
struct vect3{
  double x, y, z;
}; 

struct vector{
  double x;
  vector *next;
};
  
struct vecfam{
  vector v;
  vecfam *next;
};

double norm( vector *a ){
  double n=0;
  while (a->next != NULL)
    n=n+(a.x*a.x);
    a=a->next; 
  };
  n=n+(a.x*a.x);
  return sqrt(n);  
}

double dotprod( vector *a, vector *b ){
  double n=0;
  while ((a->next != NULL)&&(b->next != NULL)){
    n=n+(a.x*b.x);
    a=a->next;
    b=b->next; 
  };
  n=n+(a.x*b.x);
  return sqrt(n);  
} 

vector multscalar( vector *a, double c ){
  while (a->next != NULL){
    a.x=c*a.x;
    a=a->next;
  };
  a.x=c*a.x;
  return a;
}

vector addvectors( vector *a, vector *b){
  vector *c =new vector, *d;
  while ((a->next != NULL)&&(b->next != NULL)){
    c.x=a.x+b.x;
    
  };
}

vector subvectors (

vector unitvect( vector *a){
  return multscalar (a, 1/norm(a));
}

double norm2( vect2 a ){
  return sqrt((a.x*a.x)+(a.y*a.y));
}
 
double dot2( vect2 a, vect2 b){
  return (a.x*b.x)+(a.y+b.y);
}

double angle2( vect2 a, vect2 b){
  return arccos(dot2(a, b)/(norm2(a)*norm2(b)));
}

vect2 multscal2( vect2 a, double c){
  a.x=c*a.x;
  a.y=c*a.y;
  return a;
}

vect2 addvect2( vect2 a, vect2 b){
  vect2 c;
  c.x=a.x+b.x;
  c.y=a.y+b.y;
  return c;
}

vect2 subvect2( vect2 a, vect2 b){
  vect2 c;
  c.x=a.x-b.x;
  c.y=a.y-b.y;
  return c;
}

vect2 unitvect2( vect2 a ){
  return multscal2( a, norm2(a) );
}

double norm3( vect3 a ){
  return sqrt((a.x*a.x)+(a.y*a.y)+(a.z*a.z));
}

double dot3( vect3 a, vect3 b, vect3 c){
  return (a.x*b.x)+(a.y*b.y)+(a.z*b.z);
}

double angle3( vect3 a, vect3 b){
  return arccos(dot3(a, b)/(norm3(a)*norm3(b)));
}

vect3 multscal3( vect3 a, double c){
  a.x=c*a.x;
  a.y=c*a.y;
  a.z=c*a.z;
  return a;
}

vect3 addvect3( vect3 a, vect3 b){
  vect3 c;
  c.x=a.x+b.x;
  c.y=a.y+b.y;
  c.z=a.z+b.z;
  return c;
}

vect3 subvect3( vect3 a, vect3 b){
  vect3 c;
  c.x=a.x-b.x;
  c.y=a.y-b.y;
  c.z=a.z-b.z;
  return c;
}

vect3 unitvect3( vect3 a ){
  return multscal3( a, norm3(a) );
}

vect3 cross( vect3 a, vect3 b){
  vect3 c;
  c.x=(a.y*b.z)-(a.z*b.y);
  c.y=(a.z*b.x)-(a.x*b.z);
  c.z=(a.x*b.y)-(a.y*b.x);
  return c;
} 

